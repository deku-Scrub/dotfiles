<!DOCTYPE html>
<!-- saved from url=(0058)http://redsymbol.net/articles/unofficial-bash-strict-mode/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <title>Bash Strict Mode</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Bootstrap -->
<link rel="stylesheet" href="./Bash Strict Mode_files/bootstrap.min.css">
<link rel="stylesheet" href="./Bash Strict Mode_files/bootstrap-theme.min.css">

<link rel="stylesheet" href="./Bash Strict Mode_files/redsymbol.css">
    
    <meta name="keywords" content="">
    <meta name="description" content="">
    
        <link rel="stylesheet" type="text/css" href="./Bash Strict Mode_files/pygments_default.css">
 
  </head>
  <body>
    <div class="container">
    <header><a href="http://redsymbol.net/">aaron maxwell</a></header>
      <div class="row">
            <nav class="col-md-4">
        <!-- AddThis Button BEGIN -->
<!-- AddThis Button END -->

        <ul>
          <li><a href="http://redsymbol.net/resume/">resume</a></li>
          <li><a href="https://github.com/redsymbol?tab=repositories">software</a></li>
          <li><a href="http://redsymbol.net/articles/">writing</a></li>
          <li><a href="http://redsymbol.net/web/">web</a></li>
        </ul>
      </nav>

      <div id="content" class="col-md-8">
        
<h1>Use Bash Strict Mode (Unless You Love Debugging)</h1>

<p>Let's start with the punchline. Your bash scripts will be more
robust, reliable and maintainable if you start them like this:</p>


<div class="highlight"><pre><ol><li><div class="line"><span class="c">#!/bin/bash</span>
</div></li><li><div class="line"><span class="nb">set</span> -euo pipefail
</div></li><li><div class="line"><span class="nv">IFS</span><span class="o">=</span><span class="s1">$'\n\t'</span>
</div></li></ol></pre></div>



<p>I call this the unofficial <strong>bash strict mode</strong>. This
causes bash to behave in a way that makes many classes of subtle bugs
impossible.  You'll spend much less time debugging, and also avoid
having unexpected complications in production.</p>

<p>There is a short-term downside: these settings make certain common
bash idioms harder to work with. Most have simple workarounds,
detailed below: jump to <a href="http://redsymbol.net/articles/unofficial-bash-strict-mode/#issues-and-solutions">Issues &amp; Solutions</a>. But first,
let's look at what these obscure lines actually do.</p>

<h2>The "set" lines</h2>

<p>These lines deliberately cause your script to fail. Wait, what?
Believe me, this is a good thing. With these settings, certain common
errors will cause the script to <em>immediately</em> fail, explicitly
and loudly. Otherwise, you can get hidden bugs that are discovered
only when they blow up in production.
</p>

<p><code>set -euo pipefail</code> is short for:</p>

<div class="highlight"><pre><ol><li><div class="line"><span class="nb">set</span> -e
</div></li><li><div class="line"><span class="nb">set</span> -u
</div></li><li><div class="line"><span class="nb">set</span> -o pipefail
</div></li></ol></pre></div>


<p>Let's look at each separately.</p>

<h3>set -e</h3>
<p>The <code>set -e</code> option instructs bash to immediately exit
if any command <a href="http://redsymbol.net/articles/unofficial-bash-strict-mode/#footnote-1">[1]</a> has a non-zero exit
status. You wouldn't want to set this for your command-line shell, but
in a script it's massively helpful. In all widely used general-purpose
programming languages, an unhandled runtime error - whether that's a
thrown exception in Java, or a segmentation fault in C, or a syntax
error in Python - immediately halts execution of the program;
subsequent lines are not executed.</p>

<p>By default, bash does <strong>not</strong> do this. This default
behavior is exactly what you want if you are using bash on the command
line - you don't want a typo to log you out! But in a script, you
really want the opposite. If one line in a script fails, but the last
line succeeds, the whole script has a successful exit code. That makes
it very easy to miss the error.</p>

<p>
Again, what you want when using bash as your command-line shell and
using it in scripts are at odds here. Being intolerant of errors is a
lot better in scripts, and that's what <code>set -e</code> gives
you.</p>

<h3>set -u</h3>
<p><code>set -u</code> affects variables. When set, a reference to
any variable you haven't previously defined - with the exceptions of <code>$*</code>
and <code>$@</code> - is an error, and causes the program to immediately
exit. Languages like Python, C, Java and more all behave the same way,
for all sorts of good reasons. One is so typos don't create new
variables without you realizing it. For example:</p>


<div class="highlight"><pre><ol><li><div class="line"><span class="c">#!/bin/bash</span>
</div></li><li><div class="line"><span class="nv">firstName</span><span class="o">=</span><span class="s2">"Aaron"</span>
</div></li><li><div class="line"><span class="nv">fullName</span><span class="o">=</span><span class="s2">"$firstname Maxwell"</span>
</div></li><li><div class="line"><span class="nb">echo</span> <span class="s2">"$fullName"</span>
</div></li></ol></pre></div>



<p>Take a moment and look. Do you see the error? The right-hand side
of the third line says "firstname", all lowercase, instead of the
camel-cased "firstName". Without the -u option, this will be a silent
error.  But with the -u option, the script exits on that line with an
exit code of 1, printing the message "firstname: unbound variable" to
stderr.  This is what you want: have it fail explicitly and
immediately, rather than create subtle bugs that may be discovered too
late.
</p>

<h3>set -o pipefail</h3>
<p>This setting prevents errors in a pipeline from being masked. If
any command in a pipeline fails, that return code will be used as the
return code of the whole pipeline. By default, the pipeline's return
code is that of the last command - even if it succeeds. Imagine
finding a sorted list of matching lines in a file:</p>


<div class="highlight"><pre><ol><li><div class="line">% grep some-string /non/existent/file | sort
</div></li><li><div class="line">grep: /non/existent/file: No such file or directory
</div></li><li><div class="line">% <span class="nb">echo</span> <span class="nv">$?</span>
</div></li><li><div class="line">0
</div></li></ol></pre></div>



<p>(<code>%</code> is the bash prompt.) Here, grep has an exit code of
2, writes an error message to stderr, and an empty string to
stdout. This empty string is then passed through sort, which happily
accepts it as valid input, and returns a status code of 0. This is
fine for a command line, but bad for a shell script: you almost
certainly want the script to exit right then with a nonzero exit
code... like this:</p>


<div class="highlight"><pre><ol><li><div class="line">% <span class="nb">set</span> -o pipefail
</div></li><li><div class="line">% grep some-string /non/existent/file | sort
</div></li><li><div class="line">grep: /non/existent/file: No such file or directory
</div></li><li><div class="line">% <span class="nb">echo</span> <span class="nv">$?</span>
</div></li><li><div class="line">2
</div></li></ol></pre></div>



<h2>Setting IFS</h2>

<p>The IFS variable - which stands for <strong>I</strong>nternal
<strong>F</strong>ield <strong>S</strong>eparator - controls what Bash
calls <em>word splitting</em>. When set to a string, each character in
the string is considered by Bash to separate words. This governs how
bash will iterate through a sequence. For example, this script:
</p>


<div class="highlight"><pre><ol><li><div class="line"><span class="c">#!/bin/bash</span>
</div></li><li><div class="line"><span class="nv">IFS</span><span class="o">=</span><span class="s1">$' '</span>
</div></li><li><div class="line"><span class="nv">items</span><span class="o">=</span><span class="s2">"a b c"</span>
</div></li><li><div class="line"><span class="k">for </span>x in <span class="nv">$items</span>; <span class="k">do</span>
</div></li><li><div class="line"><span class="k">    </span><span class="nb">echo</span> <span class="s2">"$x"</span>
</div></li><li><div class="line"><span class="k">done</span>
</div></li><li><div class="line">
</div></li><li><div class="line"><span class="nv">IFS</span><span class="o">=</span><span class="s1">$'\n'</span>
</div></li><li><div class="line"><span class="k">for </span>y in <span class="nv">$items</span>; <span class="k">do</span>
</div></li><li><div class="line"><span class="k">    </span><span class="nb">echo</span> <span class="s2">"$y"</span>
</div></li><li><div class="line"><span class="k">done</span>
</div></li></ol></pre></div>



<p>... will print out this:</p>

<pre>a
b
c
a b c
</pre>

<p>In the first for loop, IFS is set to <code>$' '</code>. (The
<code>$'...'</code> syntax creates a string, with backslash-escaped
characters replaced with special characters - like "\t" for tab and
"\n" for newline.)  Within the for loops, x and y are set to whatever
bash considers a "word" in the original sequence. For the first loop,
IFS is a space, meaning that words are separated by a space
character. For the second loop, "words" are separated by a
<em>newline</em>, which means bash considers the whole value of
"items" as a single word.  If IFS is more than one character,
splitting will be done on <em>any</em> of those characters.
</p>

<p>Got all that? The next question is, why are we setting IFS to a
string consisting of a tab character and a newline? Because it gives
us better behavior when iterating over a loop. By "better", I mean
"much less likely to cause surprising and confusing bugs". This is
apparent in working with bash arrays:</p>


<div class="highlight"><pre><ol><li><div class="line"><span class="c">#!/bin/bash</span>
</div></li><li><div class="line"><span class="nv">names</span><span class="o">=(</span>
</div></li><li><div class="line">  <span class="s2">"Aaron Maxwell"</span>
</div></li><li><div class="line">  <span class="s2">"Wayne Gretzky"</span>
</div></li><li><div class="line">  <span class="s2">"David Beckham"</span>
</div></li><li><div class="line">  <span class="s2">"Anderson da Silva"</span>
</div></li><li><div class="line"><span class="o">)</span>
</div></li><li><div class="line">
</div></li><li><div class="line"><span class="nb">echo</span> <span class="s2">"With default IFS value..."</span>
</div></li><li><div class="line"><span class="k">for </span>name in <span class="k">${</span><span class="nv">names</span><span class="p">[@]</span><span class="k">}</span>; <span class="k">do</span>
</div></li><li><div class="line"><span class="k">  </span><span class="nb">echo</span> <span class="s2">"$name"</span>
</div></li><li><div class="line"><span class="k">done</span>
</div></li><li><div class="line">
</div></li><li><div class="line"><span class="nb">echo</span> <span class="s2">""</span>
</div></li><li><div class="line"><span class="nb">echo</span> <span class="s2">"With strict-mode IFS value..."</span>
</div></li><li><div class="line"><span class="nv">IFS</span><span class="o">=</span><span class="s1">$'\n\t'</span>
</div></li><li><div class="line"><span class="k">for </span>name in <span class="k">${</span><span class="nv">names</span><span class="p">[@]</span><span class="k">}</span>; <span class="k">do</span>
</div></li><li><div class="line"><span class="k">  </span><span class="nb">echo</span> <span class="s2">"$name"</span>
</div></li><li><div class="line"><span class="k">done</span>
</div></li></ol></pre></div>



<p>(Yes, I'm putting my name on a list of great athletes. Indulge me.) This is the output:</p>

<pre>With default IFS value...
Aaron
Maxwell
Wayne
Gretzky
David
Beckham
Anderson
da
Silva

With strict-mode IFS value...
Aaron Maxwell
Wayne Gretzky
David Beckham
Anderson da Silva
</pre>

<p>Or consider a script that takes filenames as command line arguments:</p>


<div class="highlight"><pre><ol><li><div class="line"><span class="k">for </span>arg in <span class="nv">$@</span>; <span class="k">do</span>
</div></li><li><div class="line"><span class="k">    </span><span class="nb">echo</span> <span class="s2">"doing something with file: $arg"</span>
</div></li><li><div class="line"><span class="k">done</span>
</div></li></ol></pre></div>



<p>If you invoke this as <code>myscript.sh notes todo-list 'My Resume.doc'</code>,
then with the default IFS value, the third argument will be mis-parsed
as two separate files - named "My" and "Resume.doc". When actually it's a file
that has a space in it, named "My Resume.doc".</p>

<p>Which behavior is more generally useful? The second, of course -
where we have the ability to not split on spaces. If we have an array
of strings that in general contain spaces, we normally want to iterate
through them item by item, and not split an individual item into
several.
</p>

<p>Setting IFS to <code>$'\n\t'</code> means that word splitting will
happen only on newlines and tab characters. This very often produces
useful splitting behavior. By default, bash sets this to <code>$'
\n\t'</code> - space, newline, tab - which is too eager. <a href="http://redsymbol.net/articles/unofficial-bash-strict-mode/#footnote-2">[2]</a></p>

<h2 id="issues-and-solutions">Issues &amp; Solutions</h2>

<p>I've been using the unofficial bash strict mode for years. At this
point, it always immediately saves me time and debugging
headaches. But at first it was challenging, because many of my usual
habits and idioms didn't work under under these settings.  The rest of
this article catalogues some problems you may encounter, and how to
quickly work around them.</p>

<p>(If you run into a problem you don't see here, <a href="http://redsymbol.net/articles/unofficial-bash-strict-mode/#contact-for-help">email me</a> and I will attempt to help.)</p>

<ul>
    <li><a href="http://redsymbol.net/articles/unofficial-bash-strict-mode/#sourcing-nonconforming-document">Sourcing A Nonconforming Document</a></li>
    <li><a href="http://redsymbol.net/articles/unofficial-bash-strict-mode/#solution-positional-parameters">Positional Parameters</a></li>
    <li><a href="http://redsymbol.net/articles/unofficial-bash-strict-mode/#intentionally-undefined-variables">Intentionally Undefined Variables</a></li>
    <li><a href="http://redsymbol.net/articles/unofficial-bash-strict-mode/#expect-nonzero-exit-status">Commands You Expect To Have Nonzero Exit Status</a></li>
    <li><a href="http://redsymbol.net/articles/unofficial-bash-strict-mode/#essential-cleanup">Essential Clean-up</a></li>
    <li><a href="http://redsymbol.net/articles/unofficial-bash-strict-mode/#short-circuiting">Short-Circuiting Considerations</a></li>
    <li><a href="http://redsymbol.net/articles/unofficial-bash-strict-mode/#contact-for-help">Feedback / If You Get Stuck</a></li>
</ul>

<h3 id="sourcing-nonconforming-document">Sourcing A Nonconforming Document</h3>

<p>Sometimes your script needs to source a file that doesn't work with
your strict mode. What then?</p><p>


</p><div class="highlight"><pre><ol><li><div class="line"><span class="nb">source </span>some/bad/file.env
</div></li><li><div class="line"><span class="c"># Your strict-mode script immediately exits here,</span>
</div></li><li><div class="line"><span class="c"># with a fatal error.</span>
</div></li></ol></pre></div>



<p>The solution is to (a) temporarily disable that aspect of strict mode;
(b) source the document; then (c) re-enable, on the next line.</p>

<p>The most common time you'll need this will be when the document
references an undefined variable. Temporarily allow such a
transgression with <code>set +u</code>:</p>


<div class="highlight"><pre><ol><li><div class="line"><span class="nb">set</span> +u
</div></li><li><div class="line"><span class="nb">source </span>some/bad/file.env
</div></li><li><div class="line"><span class="nb">set</span> -u
</div></li></ol></pre></div>



<p>(Remember, <code>set +u</code> <em>disables</em> this variable
strictness, and <code>set -u</code> <em>enables</em> it. A bit
counterintuitive, so take care here until it's second nature.)</p>

<p>You used to need this with Python virtual environments.  If you are
not familiar with Python: you can set up a custom, isolated
environment - called a virtualenv - stored in a directory, named
something like "venv". You elect to use this by sourcing a file named
"bin/activate" within:
</p>


<div class="highlight"><pre><ol><li><div class="line"><span class="c"># This will update PATH and set PYTHONPATH to</span>
</div></li><li><div class="line"><span class="c"># use the preconfigured virtual environment.</span>
</div></li><li><div class="line"><span class="nb">source</span> /path/to/venv/bin/activate
</div></li><li><div class="line">
</div></li><li><div class="line"><span class="c"># Now the desired version of Python is in your path,</span>
</div></li><li><div class="line"><span class="c"># with the specific set of libraries you need.</span>
</div></li><li><div class="line">python my_program.py
</div></li></ol></pre></div>



<p>In modern versions of Python, this works great with bash strict
mode. But virtual environments that are a bit older - yet young
enough you might still run into them - do <em>not</em> work correctly
with the -u option:</p>


<div class="highlight"><pre><ol><li><div class="line"><span class="nb">set</span> -u
</div></li><li><div class="line"><span class="nb">source</span> /path/to/venv/bin/activate
</div></li><li><div class="line">_OLD_VIRTUAL_PYTHONHOME: unbound variable
</div></li><li><div class="line"><span class="c"># This causes your strict-mode script to exit with an error.</span>
</div></li></ol></pre></div>



<p>No problem, you just use the pattern above:</p>


<div class="highlight"><pre><ol><li><div class="line"><span class="nb">set</span> +u
</div></li><li><div class="line"><span class="nb">source</span> /path/to/venv/bin/activate
</div></li><li><div class="line"><span class="nb">set</span> -u
</div></li></ol></pre></div>



<p>In my experience, sourced documents rarely need
<code>-e</code> or <code>-o pipefail</code> to be disabled. But if you
ever encounter that, you deal with it the same way.</p>

<h3 id="solution-positional-parameters">Positional Parameters</h3>

<p>The <code>-u</code> setting causes the script to immediately exit
if any undefined variable references are made, except for
<code>$*</code> or <code>$@</code>. But what if your script takes
positional arguments - <code>$1</code>, <code>$2</code>, etc. - and
you want to verify that they were supplied? Consider this script named
<code>sayhello.sh</code>:
</p>

<p>If you run "sayhello.sh" by itself, here's what happens:</p>

<pre>% ./sayhello.sh 
./sayhello.sh: line 3: $1: unbound variable
</pre>

<p>A most unhelpful error message. The solution is to use <a href="http://www.gnu.org/software/bash/manual/bashref.html#Shell-Parameter-Expansion">parameter
default values</a>. The idea is that if a reference is made <em>at
runtime</em> to an undefined variable, bash has a syntax for declaring
a default value, using the ":-" operator:</p>


<div class="highlight"><pre><ol><li><div class="line"><span class="c"># Variable $foo has not been set. In strict mode,</span>
</div></li><li><div class="line"><span class="c"># next line triggers an error.</span>
</div></li><li><div class="line"><span class="nv">bar</span><span class="o">=</span><span class="nv">$foo</span>
</div></li><li><div class="line">
</div></li><li><div class="line"><span class="c"># ${VARNAME:-DEFAULT_VALUE} evals to DEFAULT_VALUE if VARNAME undefined.</span>
</div></li><li><div class="line"><span class="c"># So here, $bar is set to "alpha":</span>
</div></li><li><div class="line"><span class="nv">bar</span><span class="o">=</span><span class="k">${</span><span class="nv">foo</span><span class="k">:-</span><span class="nv">alpha</span><span class="k">}</span>
</div></li><li><div class="line">
</div></li><li><div class="line"><span class="c"># Now we set foo explicitly:</span>
</div></li><li><div class="line"><span class="nv">foo</span><span class="o">=</span><span class="s2">"beta"</span>
</div></li><li><div class="line">
</div></li><li><div class="line"><span class="c"># ... and the default value is ignored. Here $bar is set to "beta":</span>
</div></li><li><div class="line"><span class="nv">bar</span><span class="o">=</span><span class="k">${</span><span class="nv">foo</span><span class="k">:-</span><span class="nv">alpha</span><span class="k">}</span>
</div></li><li><div class="line">
</div></li><li><div class="line"><span class="c"># To make the default an empty string, use ${VARNAME:-}</span>
</div></li><li><div class="line"><span class="nv">empty_string</span><span class="o">=</span><span class="k">${</span><span class="nv">some_undefined_var</span><span class="k">:-}</span>
</div></li></ol></pre></div>



<p>Under strict mode, you need to use this for all positional
parameter references:</p>


<div class="highlight"><pre><ol><li><div class="line"><span class="c">#!/bin/bash</span>
</div></li><li><div class="line"><span class="nb">set</span> -u
</div></li><li><div class="line"><span class="nv">name</span><span class="o">=</span><span class="k">${</span><span class="nv">1</span><span class="k">:-}</span>
</div></li><li><div class="line"><span class="k">if</span> <span class="o">[[</span> -z <span class="s2">"$name"</span> <span class="o">]]</span>; <span class="k">then</span>
</div></li><li><div class="line"><span class="k">    </span><span class="nb">echo</span> <span class="s2">"usage: $0 NAME"</span>
</div></li><li><div class="line">    <span class="nb">exit </span>1
</div></li><li><div class="line"><span class="k">fi</span>
</div></li><li><div class="line"><span class="nb">echo</span> <span class="s2">"Hello, $name"</span>
</div></li></ol></pre></div>



<h3 id="intentionally-undefined-variables">Intentionally Undefined Variables</h3>

<p>In the default mode, a reference to an undefined variable evaluates
to an empty string - a behavior that is sometimes relied on.  That's
not an option in strict mode, and there are a couple of ways to deal
with it. I think the best one is to explicitly set the variable to an
empty string early on in the script, before any reference to it:
</p>


<div class="highlight"><pre><ol><li><div class="line"><span class="nv">someVar</span><span class="o">=</span><span class="s2">""</span>
</div></li><li><div class="line"><span class="c"># ...</span>
</div></li><li><div class="line"><span class="c"># a bunch of lines of code that may or may not set someVar</span>
</div></li><li><div class="line"><span class="c"># ...</span>
</div></li><li><div class="line"><span class="k">if</span> <span class="o">[[</span> -z <span class="s2">"$someVar"</span> <span class="o">]]</span>; <span class="k">then</span>
</div></li><li><div class="line"><span class="c"># ...</span>
</div></li></ol></pre></div>



<p>An alternative could be to use the <code>${someVar:-}</code> syntax
for default values, described under <a href="http://redsymbol.net/articles/unofficial-bash-strict-mode/#solution-positional-parameters">Positional Parameters</a>. The
problem there is that it's possible to forget and just say
<code>$someVar</code>, plus it's more typing.  Just set the default
value explicitly at the top of your script. Then there's no way this
can bite you.
</p>

<h3 id="expect-nonzero-exit-status">Commands You Expect To Have Nonzero Exit Status</h3>

<p>What happens when you <em>want</em> to run a command that will
fail, or which you know will have a nonzero exit code?  You don't want
it to stop your script, because that's actually correct behavior.</p>

<p>There are two choices here. The simplest, which you will usually want to use,
is to append "<code>|| true</code>" after the command:</p>


<div class="highlight"><pre><ol><li><div class="line"><span class="c"># "grep -c" reports the number of matching lines. If the number is 0,</span>
</div></li><li><div class="line"><span class="c"># then grep's exit status is 1, but we don't care - we just want to</span>
</div></li><li><div class="line"><span class="c"># know the number of matches, even if that number is zero.</span>
</div></li><li><div class="line">
</div></li><li><div class="line"><span class="c"># Under strict mode, the next line aborts with an error:</span>
</div></li><li><div class="line"><span class="nv">count</span><span class="o">=</span><span class="k">$(</span>grep -c some-string some-file<span class="k">)</span>
</div></li><li><div class="line">
</div></li><li><div class="line"><span class="c"># But this one behaves more nicely:</span>
</div></li><li><div class="line"><span class="nv">count</span><span class="o">=</span><span class="k">$(</span>grep -c some-string some-file <span class="o">||</span> <span class="nb">true</span><span class="k">)</span>
</div></li><li><div class="line">
</div></li><li><div class="line"><span class="nb">echo</span> <span class="s2">"count: $count"</span>
</div></li></ol></pre></div>



<p>This short-circuiting with the boolean operator makes the expression inside
<code>$( ... )</code> always evaluate successfully.</p>

<p>You will probably find that trick almost always solves your
problem. But what if you want to know the return value of a command,
even if that return value is nonzero? Then you can temporarily disable
the exit-immediately option:</p>


<div class="highlight"><pre><ol><li><div class="line"><span class="c"># We had started out this script with set -e . And then...</span>
</div></li><li><div class="line">
</div></li><li><div class="line"><span class="nb">set</span> +e
</div></li><li><div class="line"><span class="nv">count</span><span class="o">=</span><span class="k">$(</span>grep -c some-string some-file<span class="k">)</span>
</div></li><li><div class="line"><span class="nv">retval</span><span class="o">=</span><span class="nv">$?</span>
</div></li><li><div class="line"><span class="nb">set</span> -e
</div></li><li><div class="line">
</div></li><li><div class="line"><span class="c"># grep's return code is 0 when one or more lines match;</span>
</div></li><li><div class="line"><span class="c"># 1 if no lines match; and 2 on an error. This pattern</span>
</div></li><li><div class="line"><span class="c"># lets us distinguish between them.</span>
</div></li><li><div class="line">
</div></li><li><div class="line"><span class="nb">echo</span> <span class="s2">"return value: $retval"</span>
</div></li><li><div class="line"><span class="nb">echo</span> <span class="s2">"count: $count"</span>
</div></li></ol></pre></div>



<h3 id="essential-cleanup">Essential Clean-up</h3>

<p>Suppose your script is structured like:</p>
<ol>
    <li>Spin up some expensive resource</li>
    <li>Do something with it</li>
    <li>Release that resource so it doesn't keep running and generate a giant bill</li>
</ol>

<p>For "expensive resource", this can be something like an EC2
instance that costs you real money. Or it could be something much
smaller - like a scratch directory - that you want to create for the
script to use, then be sure to delete once it is complete (so it
doesn't leak storage, etc.) With the <code>set -e</code> option, it is
possible an error will cause your script to exit before it can
perform the cleanup, which is not acceptable.</p>

<p>The solution: use <a href="http://redsymbol.net/articles/bash-exit-traps/">bash exit
traps</a>. The linked article explains this important pattern in
detail, and I highly recommend you master the technique - having it in
your toolbox significantly makes your scripts more robust and
reliable. In brief, you define a bash function that performs the
clean-up or release of resources, and then register the function to be
automatically invoked on exit. Here's how you would use it to robustly
clean up a scratch directory:
</p>


<div class="highlight"><pre><ol><li><div class="line"><span class="nv">scratch</span><span class="o">=</span><span class="k">$(</span>mktemp -d -t tmp.XXXXXXXXXX<span class="k">)</span>
</div></li><li><div class="line"><span class="k">function </span>finish <span class="o">{</span>
</div></li><li><div class="line">  rm -rf <span class="s2">"$scratch"</span>
</div></li><li><div class="line"><span class="o">}</span>
</div></li><li><div class="line"><span class="nb">trap </span>finish EXIT
</div></li><li><div class="line">
</div></li><li><div class="line"><span class="c"># Now your script can write files in the directory "$scratch".</span>
</div></li><li><div class="line"><span class="c"># It will automatically be deleted on exit, whether that's due</span>
</div></li><li><div class="line"><span class="c"># to an error, or normal completion.</span>
</div></li></ol></pre></div>



<h3 id="short-circuiting">Short-Circuiting Considerations</h3>

<p>The whole point of strict mode is to convert many kinds of hidden,
intermittent, or subtle bugs into immediate, glaringly obvious
errors.  Strict mode creates some special concerns with
short-circuiting, however.  By "short-circuiting", I mean chaining
together several commands with <code>&amp;&amp;</code> or <code>||</code> -
for example:</p>


<div class="highlight"><pre><ol><li><div class="line"><span class="c"># Prints a message only if $somefile exists.</span>
</div></li><li><div class="line"><span class="o">[[</span> -f <span class="s2">"$somefile"</span> <span class="o">]]</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">"Found file: $somefile"</span>
</div></li></ol></pre></div>



<p>The first short-circuit issue can happen when chaining three or
more commands in a row:</p>


<div class="highlight"><pre><ol><li><div class="line">first_task <span class="o">&amp;&amp;</span> second_task <span class="o">&amp;&amp;</span> third_task
</div></li><li><div class="line"><span class="c"># And more lines of code following:</span>
</div></li><li><div class="line">next_task
</div></li></ol></pre></div>



<p>The potential problem: if <code>second_task</code> fails,
<code>third_task</code> will not run, and execution will continue to
the next line of code - <code>next_task</code>, in this example. This
may be exactly the behavior you want. Alternatively, you may be
intending that if <code>second_task</code> fails, the script
should immediately exit with its error code. In this case, the
best choice is to use a block - i.e., curly braces:</p>


<div class="highlight"><pre><ol><li><div class="line">first_task <span class="o">&amp;&amp;</span> <span class="o">{</span>
</div></li><li><div class="line">    second_task
</div></li><li><div class="line">    third_task
</div></li><li><div class="line"><span class="o">}</span>
</div></li><li><div class="line">next_task
</div></li></ol></pre></div>



<p>Because we are using the <code>-e</code> option, if
<code>second_task</code> fails, the script immediately exits. </p>

<p>The second issue is truly devious. It can sneak up when using this
common idiom:</p>


<div class="highlight"><pre><ol><li><div class="line"><span class="c"># COND &amp;&amp; COMMAND</span>
</div></li><li><div class="line"><span class="o">[[</span> -f <span class="s2">"$somefile"</span> <span class="o">]]</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">"Found file: $somefile"</span>
</div></li></ol></pre></div>



<p>When people write <code>COND &amp;&amp; COMMAND</code>, typically they mean
"if COND succeeds (or is boolean true), then execute
COMMAND. Regardless, proceed to the next line of the script." It's a
very convenient shorthand for a full "if/then/fi" clause. But when
such a construct is the <em>last line</em> of the file, strict mode
can give your script a surprising exit code:
</p>


<div class="highlight"><pre><ol><li><div class="line">% cat short-circuit-last-line.sh
</div></li><li><div class="line"><span class="c">#!/bin/bash</span>
</div></li><li><div class="line"><span class="nb">set</span> -euo pipefail
</div></li><li><div class="line"><span class="c"># omitting some lines of code...</span>
</div></li><li><div class="line">
</div></li><li><div class="line"><span class="c"># Prints a message only if $somefile exists.</span>
</div></li><li><div class="line"><span class="c"># Note structure: COND &amp;&amp; COMMAND</span>
</div></li><li><div class="line"><span class="o">[[</span> -f <span class="s2">"$somefile"</span> <span class="o">]]</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">"Found file: $somefile"</span>
</div></li><li><div class="line">
</div></li><li><div class="line">% ./short-circuit-last-line.sh
</div></li><li><div class="line">% <span class="nb">echo</span> <span class="nv">$?</span>
</div></li><li><div class="line">1
</div></li></ol></pre></div>



<p>When the script got to the last line, <code>$somefile</code> did
<em>not</em> in fact exist. Thus <code>COND</code> evaluated false,
and <code>COMMAND</code> was not executed - which is what should
happen. But the script exits with a non-zero exit code, which is a
bug: the script in fact executed correctly, so it really should exit
with 0. In fact, if the last line of code is something else, that's
exactly what we get:</p>


<div class="highlight"><pre><ol><li><div class="line">% cat short-circuit-before-last-line.sh
</div></li><li><div class="line"><span class="c">#!/bin/bash</span>
</div></li><li><div class="line"><span class="nb">set</span> -euo pipefail
</div></li><li><div class="line"><span class="c"># omitting some lines of code...</span>
</div></li><li><div class="line">
</div></li><li><div class="line"><span class="c"># Prints a message only if $somefile exists.</span>
</div></li><li><div class="line"><span class="c"># Structure: COND &amp;&amp; COMMAND</span>
</div></li><li><div class="line"><span class="c"># (When we run this, $somefile will again not exist,</span>
</div></li><li><div class="line"><span class="c"># so COMMAND will not run.)</span>
</div></li><li><div class="line"><span class="o">[[</span> -f <span class="s2">"$somefile"</span> <span class="o">]]</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">"Found file: $somefile"</span>
</div></li><li><div class="line">
</div></li><li><div class="line"><span class="nb">echo</span> <span class="s2">"Done."</span>
</div></li><li><div class="line">
</div></li><li><div class="line">% ./short-circuit-before-last-line.sh
</div></li><li><div class="line">Done.
</div></li><li><div class="line">% <span class="nb">echo</span> <span class="nv">$?</span>
</div></li><li><div class="line">0
</div></li></ol></pre></div>



<p>What's going on? It turns out the <code>-e</code> option has a
special exception in short-circuiting expressions like this: if <code>COND</code>
evaluates as false, <code>COMMAND</code> will not run, and flow of
execution will proceed to the next line. However, the result of the
entire line - the entire short-circuit expression - will be nonzero,
because <code>COND</code> was. And being the last line of the script,
that becomes the program's exit code.</p>

<p>This is the kind of bug we don't want to have, since it can be
subtle, non-obvious, and hard to reproduce. And it's mainly difficult
to deal with because it shows up <em>only</em> if it's the last
command of the file; on any other line, it is well-behaved and causes
no problem. It's easy to forget this in normal, day-to-day
development, and have it slip through the cracks. For example, what if
you delete an innocuous-looking echo statement from the end, making
a short-circuit line now be last?</p>

<p>In the specific example above, we can expand the expression in a
full "if" clause. This is perfectly well-behaved:</p>


<div class="highlight"><pre><ol><li><div class="line"><span class="c"># Prints a message only if $somefile exists.</span>
</div></li><li><div class="line"><span class="k">if</span> <span class="o">[[</span> -f <span class="s2">"$somefile"</span> <span class="o">]]</span>; <span class="k">then</span>
</div></li><li><div class="line"><span class="k">    </span><span class="nb">echo</span> <span class="s2">"Found file: $somefile"</span>
</div></li><li><div class="line"><span class="k">fi</span>
</div></li><li><div class="line">
</div></li><li><div class="line"><span class="c"># If COND is a command or program, it works the same. This:</span>
</div></li><li><div class="line">first_task <span class="o">&amp;&amp;</span> second_task
</div></li><li><div class="line">
</div></li><li><div class="line"><span class="c"># ... becomes this:</span>
</div></li><li><div class="line"><span class="k">if </span>first_task; <span class="k">then</span>
</div></li><li><div class="line"><span class="k">     </span>second_task
</div></li><li><div class="line"><span class="k">fi</span>
</div></li></ol></pre></div>



<p>What's the final, full solution? You could decide to trust yourself
and your teammates to always remember this special case. You can all
freely use short-circuiting, but simply don't allow a short-circuit
expression to be on the last line of a script, for anything actually
deployed. This may work 100% reliably for you and your team, but I
don't believe that is the case for myself and many other
developers. Of course, some kind of linter or commit hook might
help.</p>

<p>Perhaps a safer option is to decide never to use short-circuiting
at all, and always use full if-statements instead. This may be
unappealing, though: short-circuiting is convenient, and people like
to do it for a reason. For now, I'm still seeking a more satisfactory
solution.  Please contact me if you have a suggestion.</p>

<h2 id="contact-for-help">Feedback / If You Get Stuck</h2>

<p>If you have feedback or suggestions for improvements, I'd love to hear it.
Reach me (Aaron Maxwell) by email, at amax at redsymbol dot net. 
</p>

<p>Conversely, if you find strict mode causes a problem that I don't
tell you how to solve above, I want to know about that too. When you
email me, please include a <strong>minimal</strong> bash script that
demonstrates the problem in the body of the email (not as an
attachment). Also very clearly state what the desired output or effect
should be, and what error or failure you are getting instead.  You are
much more likely to get a response if your script isn't some giant
monster with obtuse identifiers that I would have to spend all
afternoon parsing.</p>

<h2>Footnotes</h2>
<ul>
    
  <li id="footnote-1">[1] Specifically, if any pipeline; any command
  in parentheses; or a command executed as part of a command list in
  braces exits with a non-zero exit status, the script exits
  immediately with that same status. There are other subtleties to
  this; see docs for the <a href="http://www.gnu.org/software/bash/manual/bashref.html#The-Set-Builtin">bash
  "set" builtin</a> for details.</li>

  <li id="footnote-2">[2] Another approach: instead of altering IFS,
  begin the loop with <code>for arg in "$@"</code> - double quoting
  the iteration variable.  This changes loop semantics to produces the
  nicer behavior, and even handles a few edge cases better. The big
  problem is maintainability. It's easy for even experienced
  developers to forget to put in the double quotes. Even if the
  original author has managed to impeccably ingrain the habit, it's
  foolish to expect that all future maintainers will. In short,
  relying on quotes has a high risk of introducing subtle time-bomb
  bugs. Setting IFS renders this impossible.
  </li>

</ul>

<div style="margin-bottom: 50em;">&nbsp;</div>


 
      </div> <!-- id="content" -->
      </div> <!-- class="row" -->
    </div> <!-- class="container" -->
    
    
    <script type="text/javascript" async="" src="./Bash Strict Mode_files/ga.js"></script><script>

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-16434333-2']);
      _gaq.push(['_setDomainName', '.redsymbol.net']);
      _gaq.push(['_trackPageview']);

      (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
     
    

    <script src="./Bash Strict Mode_files/jquery.js"></script>
    <script src="./Bash Strict Mode_files/bootstrap.min.js"></script>
  

</body><div class="vimiumReset"><template shadowrootmode="open"><style type="text/css">/*
 * Many CSS class names in this file use the verbose "vimiumXYZ" as the class name. This is so we
 * don't use the same CSS class names that the page is using, so the page's CSS doesn't mess with
 * the style of our Vimium dialogs.
 *
 * We use the maximum z-index value for all Vimium elements to guarantee that they always appear on
 * top. Chrome supports z-index values up to 2,147,483,647 (= 2^31 - 1). We utilize the maximum
 * z-index value allowable to ensure Vimium elements have precedence over all other page elements.
 */

/*
 * This vimiumReset class can be added to any of our UI elements to give it a clean slate. This is
 * useful in case the page has declared a broad rule like "a { padding: 50px; }" which will mess up
 * our UI. These declarations contain more specifiers than necessary to increase their specificity
 * (precedence).
 */
.vimiumReset,
div.vimiumReset,
span.vimiumReset,
table.vimiumReset,
a.vimiumReset,
a:visited.vimiumReset,
a:link.vimiumReset,
a:hover.vimiumReset,
td.vimiumReset,
tr.vimiumReset {
  background: none;
  border: none;
  bottom: auto;
  box-shadow: none;
  color: black;
  cursor: auto;
  display: inline;
  float: none;
  font-family: "Helvetica Neue", "Helvetica", "Arial", sans-serif;
  font-size: inherit;
  font-style: normal;
  font-variant: normal;
  font-weight: normal;
  height: auto;
  left: auto;
  letter-spacing: 0;
  line-height: 100%;
  margin: 0;
  max-height: none;
  max-width: none;
  min-height: 0;
  min-width: 0;
  opacity: 1;
  padding: 0;
  position: static;
  right: auto;
  text-align: left;
  text-decoration: none;
  text-indent: 0;
  text-shadow: none;
  text-transform: none;
  top: auto;
  vertical-align: baseline;
  white-space: normal;
  width: auto;
  z-index: 2147483647;
}

thead.vimiumReset, tbody.vimiumReset {
  display: table-header-group;
}

tbody.vimiumReset {
  display: table-row-group;
}

/* Linkhints CSS */

div#vimiumHintMarkerContainer {
  pointer-events: none;
}

div.internalVimiumHintMarker {
  position: absolute;
  display: block;
  top: -1px;
  left: -1px;
  white-space: nowrap;
  overflow: hidden;
  font-size: 11px;
  padding: 1px 3px 0px 3px;
  background: linear-gradient(to bottom, #fff785 0%, #ffc542 100%);
  border: solid 1px #c38a22;
  border-radius: 3px;
  box-shadow: 0px 3px 7px 0px rgba(0, 0, 0, 0.3);
  z-index: 2147483647;
}

div.internalVimiumHintMarker span {
  color: #302505;
  font-family: Helvetica, Arial, sans-serif;
  font-weight: bold;
  font-size: 11px;
  text-shadow: 0 1px 0 rgba(255, 255, 255, 0.6);
}

div.internalVimiumHintMarker > .matchingCharacter {
  color: #d4ac3a;
}

div > .vimiumActiveHintMarker span {
  color: #a07555 !important;
}

/* Input hints CSS */

div.internalVimiumInputHint {
  position: absolute;
  display: block;
  background-color: rgba(255, 247, 133, 0.3);
  border: solid 1px #c38a22;
  pointer-events: none;
}

div.internalVimiumSelectedInputHint {
  background-color: rgba(255, 102, 102, 0.3);
  border: solid 1px #993333 !important;
}

div.internalVimiumSelectedInputHint span {
  color: white !important;
}

/* Frame Highlight Marker CSS*/
div.vimiumHighlightedFrame {
  position: fixed;
  top: 0px;
  left: 0px;
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
  border: 5px solid yellow;
  box-sizing: border-box;
  pointer-events: none;
}

/* Help Dialog CSS */

iframe.vimiumHelpDialogFrame {
  background-color: rgba(10, 10, 10, 0.6);
  padding: 0px;
  top: 0px;
  left: 0px;
  width: 100%;
  height: 100%;
  display: block;
  position: fixed;
  border: none;
  z-index: 2147483647;
}

div#vimiumHelpDialogContainer {
  opacity: 1.0;
  background-color: white;
  border: 2px solid #b3b3b3;
  border-radius: 6px;
  width: 840px;
  max-width: calc(100% - 100px);
  max-height: calc(100% - 100px);
  margin: 50px auto;
  overflow-y: auto;
  overflow-x: auto;
}

div#vimiumHelpDialog {
  min-width: 600px;
  padding: 8px 12px;
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
}

span#vimiumTitle, span#vimiumTitle span, span#vimiumTitle * {
  font-size: 20px;
}
#vimiumTitle {
  display: block;
  line-height: 130%;
  white-space: nowrap;
}
td.vimiumHelpDialogTopButtons {
  width: 100%;
  text-align: right;
}
#helpDialogOptionsPage, #helpDialogWikiPage {
  font-size: 14px;
  padding-left: 5px;
  padding-right: 5px;
}
div.vimiumColumn {
  width: 50%;
  float: left;
  font-size: 11px;
  line-height: 130%;
}

div.vimiumColumn tr {
  display: table-row;
}

div.vimiumColumn td {
  display: table-cell;
  font-size: 11px;
  line-height: 130%;
}
div.vimiumColumn table, div.vimiumColumn td, div.vimiumColumn tr {
  padding: 0;
  margin: 0;
}
div.vimiumColumn table {
  width: 100%;
  table-layout: auto;
}
div.vimiumColumn td {
  vertical-align: top;
  padding: 1px;
}
div#vimiumHelpDialog div.vimiumColumn tr > td:first-of-type {
  /* This is the "key" column, e.g. "j", "gg". */
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 14px;
  text-align: right;
  white-space: nowrap;
}
span.vimiumHelpDialogKey {
  background-color: rgb(243, 243, 243);
  color: rgb(33, 33, 33);
  margin-left: 2px;
  padding-top: 1px;
  padding-bottom: 1px;
  padding-left: 4px;
  padding-right: 4px;
  border-radius: 3px;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  box-shadow: inset 0 -1px 0 #bbb;
  font-family: monospace;
  font-size: 11px;
}
/* Make the description column as wide as it can be. */
div#vimiumHelpDialog div.vimiumColumn tr > td:nth-of-type(3) {
  width: 100%;
}
div#vimiumHelpDialog div.vimiumDivider {
  display: block;
  height: 1px;
  width: 100%;
  margin: 10px auto;
  background-color: #9a9a9a;
}
div#vimiumHelpDialog td.vimiumHelpSectionTitle {
  padding-top: 3px;
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 16px;
  font-weight: bold;
}
div#vimiumHelpDialog td.vimiumHelpDescription {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 14px;
}
div#vimiumHelpDialog span.vimiumCopyCommandNameName {
  font-style: italic;
  cursor: pointer;
  font-size: 12px;
}
/* Advanced commands are hidden by default until you show them. */
div#vimiumHelpDialog tr.advanced {
  display: none;
}
div#vimiumHelpDialog.showAdvanced tr.advanced {
  display: table-row;
}
div#vimiumHelpDialog div.advanced td:nth-of-type(3) {
  color: #555;
}
div#vimiumHelpDialog a.closeButton {
  font-family: "courier new";
  font-weight: bold;
  color: #555;
  text-decoration: none;
  font-size: 24px;
  position: relative;
  top: 3px;
  padding-left: 5px;
  cursor: pointer;
}
div#vimiumHelpDialog a {
  text-decoration: underline;
}

div#vimiumHelpDialog a.closeButton:hover {
  color: black;
  -webkit-user-select: none;
}
div#vimiumHelpDialogFooter {
  display: block;
  position: relative;
  margin-bottom: 37px;
}
table.helpDialogBottom {
  width: 100%;
}
td.helpDialogBottomRight {
  width: 100%;
  float: right;
  text-align: right;
}
td.helpDialogBottomRight, td.helpDialogBottomLeft {
  padding: 0px;
}
div#vimiumHelpDialogFooter * {
  font-size: 10px;
}
a#toggleAdvancedCommands, span#help-dialog-tip {
  position: relative;
  top: 19px;
  white-space: nowrap;
  font-size: 10px;
}
a:link.vimiumHelDialogLink,
a:visited.vimiumHelDialogLink,
a:hover.vimiumHelDialogLink,
a:active.vimiumHelDialogLink,
a#toggleAdvancedCommands {
  color: #2f508e;
  text-decoration: underline;
  cursor: pointer;
}

/* Vimium HUD CSS */

div.vimiumHUD {
  display: block;
  position: fixed;
  width: calc(100% - 20px);
  bottom: 8px;
  left: 8px;
  background: #f1f1f1;
  text-align: left;
  border-radius: 4px;
  box-shadow: 0px 2px 10px rgba(0, 0, 0, 0.8);
  border: 1px solid #aaa;
  z-index: 2147483647;
}

iframe.vimiumHUDFrame {
  background-color: transparent;
  padding: 0px;
  overflow: hidden;
  display: block;
  position: fixed;
  width: 20%;
  min-width: 350px;
  height: 58px;
  bottom: -14px;
  right: 20px;
  margin: 0 0 0 -40%;
  border: none;
  z-index: 2147483647;
  opacity: 0;
}

div.vimiumHUD .vimiumHUDSearchArea {
  display: block;
  padding: 3px;
  background-color: #f1f1f1;
  border-radius: 4px 4px 0 0;
}

div.vimiumHUD .vimiumHUDSearchAreaInner {
  color: #777;
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 14px;
  height: 30px;
  margin-bottom: 0;
  padding: 2px 4px;
  border-radius: 3px;
  width: 100%;
  outline: none;
  box-sizing: border-box;
  line-height: 20px;
}

div.vimiumHUD .hud-find {
  background: #fff;
  border: 1px solid #ccc;
}

div.vimiumHUD span#hud-find-input, div.vimiumHUD span#hud-match-count {
  color: #000;
  display: inline;
  outline: none;
  white-space: nowrap;
  overflow-y: hidden;
}

div.vimiumHUD span#hud-find-input:before {
  content: "/";
}

div.vimiumHUD span#hud-match-count {
  color: #aaa;
  font-size: 12px;
}

div.vimiumHUD span#hud-find-input br {
  display: none;
}

div.vimiumHUD span#hud-find-input * {
  display: inline;
  white-space: nowrap;
}

body.vimiumFindMode ::selection {
  background: #ff9632;
}

/* Vomnibar Frame CSS */

iframe.vomnibarFrame {
  background-color: transparent;
  padding: 0px;
  overflow: hidden;

  display: block;
  position: fixed;
  width: calc(80% + 20px); /* same adjustment as in pages/vomnibar.js */
  min-width: 400px;
  height: calc(100% - 70px);
  top: 70px;
  left: 50%;
  margin: 0 0 0 -40%;
  border: none;
  font-family: sans-serif;
  z-index: 2147483647;
}

div.vimiumFlash {
  box-shadow: 0px 0px 4px 2px #4183c4;
  padding: 1px;
  background-color: transparent;
  position: absolute;
  z-index: 2147483647;
}

/* UIComponent CSS */
iframe.vimiumUIComponentHidden {
  display: none;
}

iframe.vimiumUIComponentVisible {
  display: block;
  color-scheme: light dark;
}

iframe.vimiumUIComponentReactivated {
  border: 5px solid yellow;
}

iframe.vimiumNonClickable {
  pointer-events: none;
}

@media (prefers-color-scheme: dark) {
  /* DarkReader is a popular dark mode browser extension. It can apply an invert filter to the whole
   * page to make the page dark, when used in Filter and Filter+ modes. We want to reverse/invert
   * that filter again for Vimium's UI elements, because Vimium is already dark mode aware. */
  iframe.reverseDarkReaderFilter {
    -webkit-filter: invert(100%) hue-rotate(180deg) !important;
    filter: invert(100%) hue-rotate(180deg) !important;
  }

  /* Dark mode CSS for options page and exclusions */

  body.vimiumBody {
    background-color: #292a2d;
    color: white;
  }

  body.vimiumBody a,
  body.vimiumBody a:visited {
    color: #8ab4f8;
  }

  body.vimiumBody textarea,
  body.vimiumBody input {
    background-color: #1d1d1f;
    border-color: #1d1d1f;
    color: #e8eaed;
  }

  body.vimiumBody div.example {
    color: #9aa0a6;
  }

  body.vimiumBody div#state,
  body.vimiumBody div#footer {
    background-color: #202124;
    border-color: rgba(255, 255, 255, 0.1);
  }

  /* Dark Mode CSS for Help Dialog */

  div#vimiumHelpDialogContainer {
    border-color: rgba(255, 255, 255, 0.1);
    background-color: #202124;
  }

  div#vimiumHelpDialog {
    background-color: #292a2d;
    color: white;
  }

  div#vimiumHelpDialog td.vimiumHelpDescription {
    color: #c9cccf;
  }

  span#vimiumTitle,
  div#vimiumHelpDialog td.vimiumHelpSectionTitle {
    color: white;
  }

  #vimiumTitle > span:first-child {
    color: #8ab4f8 !important;
  }

  div#vimiumHelpDialog a {
    color: #8ab4f8;
  }

  div#vimiumHelpDialog div.vimiumDivider {
    background-color: rgba(255, 255, 255, 0.1);
  }

  span.vimiumHelpDialogKey {
    background-color: #1d1d1f;
    border: solid 1px black;
    box-shadow: none;
    color: white;
  }
}
</style><iframe class="vimiumHUDFrame vimiumUIComponentVisible vimiumNonClickable" allow="clipboard-read; clipboard-write" src="chrome-extension://dbepggeogbaibhgnhhndojpepiihcmeb/pages/hud.html"></iframe><style type="text/css">iframe.vimiumHUDFrame.vimiumUIComponentVisible {
  opacity: 1;
}</style></template></div></html>